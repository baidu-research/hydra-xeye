///
/// @file
/// @copyright All code copyright Movidius Ltd 2014, all rights reserved.
///            For License Warranty see: common/license.txt
///
/// @brief     This file contains the source code of the SIPP pipeline
///            generated by the SIPP Graph Designer.
///
///
///  ************************ DO NOT EDIT, THIS IS A GENERATED FILE!!!! ************************
///

#include "xeye_sipp_rgb.h"

#include <include/sippHwDefs.h>
#include <arch/ma2x5x/include/sippHwDefs_ma2x5x.h>
#include "sensor_common.h"
#include "xeye_info.h"

static SensorType_t Xeye_Sensor;
static int g_digital_gain_ratio = 1;
UInt8      DDR_DATA SippRGB_dmaOut0_buffer   [SIPP_ISP_PIPE_BUFFER_WIDTH *
        SIPP_ISP_PIPE_BUFFER_HEIGHT * 3  ]ALIGNED(8);
UInt8      DDR_DATA SippRGB_dmaOut1_buffer   [SIPP_ISP_PIPE_BUFFER_WIDTH *
        SIPP_ISP_PIPE_BUFFER_HEIGHT * SIPP_ISP_PIPE_BUFFER_INPUT_NUM_PLANES]ALIGNED(8);

void setSippDigitalGainRatio(int ratio) {
    g_digital_gain_ratio = ratio;
}

void SippSetSensorType(const int sensor_type) {
    Xeye_Sensor = sensor_type;
}

void readSippRGBInput(SippRGB* pPl) {
    //Ensure parameter is used to avoid compiler warning
    (void)(pPl);
}

void writeSippRGBOutput(SippRGB* pPl) {
    sippWrFileU8((UInt8*)SippRGB_dmaOut0_buffer,
                 SIPP_ISP_PIPE_BUFFER_WIDTH * SIPP_ISP_PIPE_BUFFER_HEIGHT * 3 * sizeof(UInt8), "output.raw");
    //Ensure parameter is used to avoid compiler warning
    (void)(pPl);
}

void buildSippRGB(SippRGB* pPl) {
    // create new pipeline
    pPl->pl               = sippCreatePipeline(11, 11, SIPP_MBIN(mbinImgSipp));

    // create filters
    pPl->dmaIn0          =  sippCreateFilter(pPl->pl, 0x00,       SIPP_ISP_PIPE_BUFFER_WIDTH,
                            SIPP_ISP_PIPE_BUFFER_HEIGHT, N_PL(SIPP_ISP_PIPE_BUFFER_INPUT_NUM_PLANES), SZ(UInt16), SIPP_AUTO,
                            (FnSvuRun)SIPP_DMA_ID,        0);
    pPl->sigmaDnsMa2x5x0 =  sippCreateFilter(pPl->pl, 0x0,        SIPP_ISP_PIPE_BUFFER_WIDTH,
                            SIPP_ISP_PIPE_BUFFER_HEIGHT, N_PL(SIPP_ISP_PIPE_BUFFER_INPUT_NUM_PLANES), SZ(UInt16), SIPP_AUTO,
                            (FnSvuRun)SIPP_SIGMA_ID,      0);
    pPl->lscMa2x5x0      =  sippCreateFilter(pPl->pl, 0x0,        SIPP_ISP_PIPE_BUFFER_WIDTH,
                            SIPP_ISP_PIPE_BUFFER_HEIGHT, N_PL(SIPP_ISP_PIPE_BUFFER_INPUT_NUM_PLANES), SZ(UInt16), SIPP_AUTO,
                            (FnSvuRun)SIPP_LSC_ID,        0);
    pPl->rawMa2x5x0      =  sippCreateFilter(pPl->pl, 0x0,        SIPP_ISP_PIPE_BUFFER_WIDTH,
                            SIPP_ISP_PIPE_BUFFER_HEIGHT, N_PL(SIPP_ISP_PIPE_BUFFER_INPUT_NUM_PLANES), SZ(UInt8), SIPP_AUTO,
                            (FnSvuRun)SIPP_RAW_ID,        0);
    pPl->debayerMa2x5x0  =  sippCreateFilter(pPl->pl, 0x0,        SIPP_ISP_PIPE_BUFFER_WIDTH,
                            SIPP_ISP_PIPE_BUFFER_HEIGHT, N_PL(3),  SZ(UInt8), SIPP_AUTO, (FnSvuRun)SIPP_DBYR_ID,       0);
    sippFilterAddOBuf(pPl->debayerMa2x5x0, SIPP_ISP_PIPE_BUFFER_INPUT_NUM_PLANES, sizeof(UInt8));
    pPl->dmaOut0         =  sippCreateFilter(pPl->pl, 0x00,       SIPP_ISP_PIPE_BUFFER_WIDTH,
                            SIPP_ISP_PIPE_BUFFER_HEIGHT, N_PL(3),  SZ(UInt8), SIPP_AUTO, (FnSvuRun)SIPP_DMA_ID,        0);
    pPl->dmaOut1         =  sippCreateFilter(pPl->pl, 0x00,       SIPP_ISP_PIPE_BUFFER_WIDTH,
                            SIPP_ISP_PIPE_BUFFER_HEIGHT, N_PL(SIPP_ISP_PIPE_BUFFER_INPUT_NUM_PLANES), SZ(UInt8), SIPP_AUTO,
                            (FnSvuRun)SIPP_DMA_ID,        0);

    // link filters
    sippLinkFilter(pPl->sigmaDnsMa2x5x0, pPl->dmaIn0,        5, 5);
    sippLinkFilter(pPl->lscMa2x5x0,    pPl->sigmaDnsMa2x5x0, 1, 1);
    sippLinkFilter(pPl->rawMa2x5x0,    pPl->lscMa2x5x0,     5, 5);
    sippLinkFilter(pPl->debayerMa2x5x0, pPl->rawMa2x5x0,    11, 11);
    sippLinkFilter(pPl->dmaOut0,       pPl->debayerMa2x5x0, 1, 1);
    sippLinkFilter(pPl->dmaOut1,       pPl->debayerMa2x5x0, 1, 1);
    sippLinkFilterSetOBuf(pPl->dmaOut1, pPl->debayerMa2x5x0, 1);
}


void configSippRGB(SippRGB* pPl) {
    DmaParam*            dmaIn0Cfg          = (DmaParam*)pPl->dmaIn0->params;
    SigmaParam*          sigmaDnsMa2x5x0Cfg = (SigmaParam*)pPl->sigmaDnsMa2x5x0->params;
    LscParam*            lscMa2x5x0Cfg      = (LscParam*)pPl->lscMa2x5x0->params;
    RawParam*            rawMa2x5x0Cfg      = (RawParam*)pPl->rawMa2x5x0->params;
    DbyrParam*           debayerMa2x5x0Cfg  = (DbyrParam*)pPl->debayerMa2x5x0->params;
    DmaParam*            dmaOut0Cfg         = (DmaParam*)pPl->dmaOut0->params;
    DmaParam*            dmaOut1Cfg         = (DmaParam*)pPl->dmaOut1->params;

    uint8_t BAYER_PATTERN_locate = 0;

    if ((Xeye_Sensor == Sensor_AR0330) || (Xeye_Sensor == Sensor_AR0144)) {
        BAYER_PATTERN_locate = GRBG;
    } else {
        BAYER_PATTERN_locate = RGGB;
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // here go through all the filter instances and assign the value for all parameter
    // fields as defined in the filter property window
    sigmaDnsMa2x5x0Cfg->thresh[0] = (ISPC_SIGMA_THRESH1_P0 <<  0 | ISPC_SIGMA_THRESH2_P0 <<  8 |
                                     ISPC_SIGMA_THRESH1_P1 << 16 | ISPC_SIGMA_THRESH2_P1 << 24);
    sigmaDnsMa2x5x0Cfg->thresh[1] = (ISPC_SIGMA_THRESH1_P2 <<  0 | ISPC_SIGMA_THRESH2_P2 <<  8 |
                                     ISPC_SIGMA_THRESH1_P3 << 16 | ISPC_SIGMA_THRESH2_P3 << 24);
    sigmaDnsMa2x5x0Cfg->cfg = SIGMA_DNS_CFG(ISPC_SIGMA_NOISE_FLOOR, (ispc_bayer_bits - 1),
                                            SIGMA_DNS_PASSTHRU_BIT, FORMAT);
    sigmaDnsMa2x5x0Cfg->bayerPattern = BAYER_PATTERN_locate;
    sigmaDnsMa2x5x0Cfg->blcGR = sensor_black_level;
    sigmaDnsMa2x5x0Cfg->blcR = sensor_black_level;
    sigmaDnsMa2x5x0Cfg->blcB = sensor_black_level;
    sigmaDnsMa2x5x0Cfg->blcGB = sensor_black_level;
    lscMa2x5x0Cfg->gmBase =   ispcLscMesh;
    lscMa2x5x0Cfg->gmWidth =  ISPC_LSC_GAIN_MAP_W;
    lscMa2x5x0Cfg->gmHeight = ISPC_LSC_GAIN_MAP_H;
    lscMa2x5x0Cfg->dataFormat = SIPP_LSC_CFG_FORMAT(BAYER);
    lscMa2x5x0Cfg->dataWidth = ispc_bayer_bits;
    rawMa2x5x0Cfg->grgbPlat = RAW_GRGB_PLATO(ISPC_GRGB_IMBAL_PLAT_DARK, ISPC_GRGB_IMBAL_PLAT_BRIGHT);
    rawMa2x5x0Cfg->grgbDecay = RAW_GRGB_DECAY(ISPC_GRGB_IMBAL_DECAY_BRIGHT, ISPC_GRGB_IMBAL_DECAY_DARK);
    rawMa2x5x0Cfg->badPixCfg = RAW_BAD_PIX_CFG(ISPC_BAD_PIX_NOISE_LEVEL, ISPC_BAD_PIX_ALPHA_G_HOT,
                               ISPC_BAD_PIX_ALPHA_G_COLD, ISPC_BAD_PIX_ALPHA_RB_HOT, ISPC_BAD_PIX_ALPHA_RB_COLD);
    rawMa2x5x0Cfg->cfg =      RAW_CFG(BAYER, BAYER_PATTERN_locate, GRGB_IMBAL_EN, 0, AE_PATCH_STATS_EN,
                                      AE_RGB_HIST_STATS_EN, (ispc_bayer_bits - 1), ISPC_GRGB_IMBAL_THRESHOLD, 0, AF_PATCH_STATS_EN,
                                      BAYER_2x2_MODE, AE_Y_HIST_STATS_EN, HOT_COLD_PIX_SUPPRESS_EN);
    rawMa2x5x0Cfg->gainSat[0] = ((ispc_raw_clamp_0 << 16) | (ispc_raw_gain_gr * g_digital_gain_ratio));
    rawMa2x5x0Cfg->gainSat[1] = ((ispc_raw_clamp_1 << 16) | (ispc_raw_gain_g * g_digital_gain_ratio));
    rawMa2x5x0Cfg->gainSat[2] = ((ispc_raw_clamp_2 << 16) | (ispc_raw_gain_b * g_digital_gain_ratio));
    rawMa2x5x0Cfg->gainSat[3] = ((ispc_raw_clamp_3 << 16) | (ispc_raw_gain_gb * g_digital_gain_ratio));
    rawMa2x5x0Cfg->statsBase = 0;
    rawMa2x5x0Cfg->statsPlanes = 0;
    rawMa2x5x0Cfg->statsPatchCfg = 0;
    rawMa2x5x0Cfg->statsPatchStart = 0;
    rawMa2x5x0Cfg->statsPatchSkip = 0;
    rawMa2x5x0Cfg->statsThresh = 0;
    rawMa2x5x0Cfg->afF1coefs[0] = 0;
    rawMa2x5x0Cfg->afF1coefs[1] = 0;
    rawMa2x5x0Cfg->afF1coefs[2] = 0;
    rawMa2x5x0Cfg->afF1coefs[3] = 0;
    rawMa2x5x0Cfg->afF1coefs[4] = 0;
    rawMa2x5x0Cfg->afF1coefs[5] = 0;
    rawMa2x5x0Cfg->afF1coefs[6] = 0;
    rawMa2x5x0Cfg->afF1coefs[7] = 0;
    rawMa2x5x0Cfg->afF1coefs[8] = 0;
    rawMa2x5x0Cfg->afF1coefs[9] = 0;
    rawMa2x5x0Cfg->afF1coefs[10] = 0;
    rawMa2x5x0Cfg->afF2coefs[0] = 0;
    rawMa2x5x0Cfg->afF2coefs[1] = 0;
    rawMa2x5x0Cfg->afF2coefs[2] = 0;
    rawMa2x5x0Cfg->afF2coefs[3] = 0;
    rawMa2x5x0Cfg->afF2coefs[4] = 0;
    rawMa2x5x0Cfg->afF2coefs[5] = 0;
    rawMa2x5x0Cfg->afF2coefs[6] = 0;
    rawMa2x5x0Cfg->afF2coefs[7] = 0;
    rawMa2x5x0Cfg->afF2coefs[8] = 0;
    rawMa2x5x0Cfg->afF2coefs[9] = 0;
    rawMa2x5x0Cfg->afF2coefs[10] = 0;
    rawMa2x5x0Cfg->afMinThresh = 0;
    rawMa2x5x0Cfg->afSubtract = 0;
    rawMa2x5x0Cfg->afPatchCfg = 0;
    rawMa2x5x0Cfg->afPatchStart = 0;
    rawMa2x5x0Cfg->afStatsBase = 0;
    //rawMa2x5x0Cfg->histLumaBase=histLuma;
    rawMa2x5x0Cfg->histLumaBase = 0;
    rawMa2x5x0Cfg->histRgbBase = 0;
    debayerMa2x5x0Cfg->cfg =  DEBAYER_CFG(BAYER_PATTERN_locate, 0, 0, ispc_bayer_bits, 8, P_RGB, 3, 0);
    debayerMa2x5x0Cfg->thresh = DEBAYER_THRESH(0, 0, 1, 1, 1, 0);
    debayerMa2x5x0Cfg->dewormCfg = DEBAYER_DEWORM(0, 0);
    debayerMa2x5x0Cfg->lumaWeight = DEBAYER_LUMA_COEFS_CFG(ISPC_DEMOSAIC_LUMA_WEIGHT_RED ,
                                    ISPC_DEMOSAIC_LUMA_WEIGHT_GREEN, ISPC_DEMOSAIC_LUMA_WEIGHT_BLUE);
    dmaIn0Cfg->ddrAddr   = (UInt32)NULL;
    dmaOut0Cfg->ddrAddr  = (UInt32)&SippRGB_dmaOut0_buffer;
    dmaOut1Cfg->ddrAddr  = (UInt32)&SippRGB_dmaOut1_buffer;


}
